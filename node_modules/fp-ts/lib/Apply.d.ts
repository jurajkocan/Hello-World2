import { HKT, HKTS, HKT2S, HKTAs, HKT2As } from './HKT';
import { Functor, FantasyFunctor } from './Functor';
import { Curried2, Curried3, Curried4 } from './function';
export interface Apply<F> extends Functor<F> {
    ap: <A, B>(fab: HKT<F, (a: A) => B>, fa: HKT<F, A>) => HKT<F, B>;
}
export interface FantasyApply<F, A> extends FantasyFunctor<F, A> {
    ap: <B>(fab: HKT<F, (a: A) => B>) => HKT<F, B>;
}
export declare class Ops {
    /** Combine two effectful actions, keeping only the result of the first */
    applyFirst<F extends HKT2S>(apply: Apply<F>): <L, A>(fa: HKT2As<F, L, A>) => <B>(fb: HKT2As<F, L, B>) => HKT2As<F, L, A>;
    applyFirst<F extends HKTS>(apply: Apply<F>): <A>(fa: HKTAs<F, A>) => <B>(fb: HKTAs<F, B>) => HKTAs<F, A>;
    applyFirst<F>(apply: Apply<F>): <A>(fa: HKT<F, A>) => <B>(fb: HKT<F, B>) => HKT<F, A>;
    /** Combine two effectful actions, keeping only the result of the second */
    applySecond<F extends HKT2S>(apply: Apply<F>): <L, A>(fa: HKT2As<F, L, A>) => <B>(fb: HKT2As<F, L, B>) => HKT2As<F, L, B>;
    applySecond<F extends HKTS>(apply: Apply<F>): <A>(fa: HKTAs<F, A>) => <B>(fb: HKTAs<F, B>) => HKTAs<F, B>;
    applySecond<F>(apply: Apply<F>): <A>(fa: HKT<F, A>) => <B>(fb: HKT<F, B>) => HKT<F, B>;
    /**
     * Lift a function of two arguments to a function which accepts and returns
     * values wrapped with the type constructor `F`
     */
    liftA2<F extends HKT2S>(apply: Apply<F>): <A, B, C>(f: Curried2<A, B, C>) => <L>(fa: HKT2As<F, L, A>) => (fb: HKT2As<F, L, B>) => HKT2As<F, L, C>;
    liftA2<F extends HKTS>(apply: Apply<F>): <A, B, C>(f: Curried2<A, B, C>) => Curried2<HKTAs<F, A>, HKTAs<F, B>, HKTAs<F, C>>;
    liftA2<F>(apply: Apply<F>): <A, B, C>(f: Curried2<A, B, C>) => Curried2<HKT<F, A>, HKT<F, B>, HKT<F, C>>;
    /**
     * Lift a function of three arguments to a function which accepts and returns
     * values wrapped with the type constructor `F`
     */
    liftA3<F extends HKT2S>(apply: Apply<F>): <A, B, C, D>(f: Curried3<A, B, C, D>) => <L>(fa: HKT2As<F, L, A>) => (fb: HKT2As<F, L, B>) => (fc: HKT2As<F, L, C>) => HKT2As<F, L, D>;
    liftA3<F extends HKTS>(apply: Apply<F>): <A, B, C, D>(f: Curried3<A, B, C, D>) => Curried3<HKTAs<F, A>, HKTAs<F, B>, HKTAs<F, C>, HKTAs<F, D>>;
    liftA3<F>(apply: Apply<F>): <A, B, C, D>(f: Curried3<A, B, C, D>) => Curried3<HKT<F, A>, HKT<F, B>, HKT<F, C>, HKT<F, D>>;
    /**
     * Lift a function of four arguments to a function which accepts and returns
     * values wrapped with the type constructor `F`
     */
    liftA4<F extends HKT2S>(apply: Apply<F>): <A, B, C, D, E>(f: Curried4<A, B, C, D, E>) => <L>(fa: HKT2As<F, L, A>) => (fb: HKT2As<F, L, B>) => (fc: HKT2As<F, L, C>) => (fd: HKT2As<F, L, D>) => HKT2As<F, L, E>;
    liftA4<F extends HKTS>(apply: Apply<F>): <A, B, C, D, E>(f: Curried4<A, B, C, D, E>) => Curried4<HKTAs<F, A>, HKTAs<F, B>, HKTAs<F, C>, HKTAs<F, D>, HKTAs<F, E>>;
    liftA4<F>(apply: Apply<F>): <A, B, C, D, E>(f: Curried4<A, B, C, D, E>) => Curried4<HKT<F, A>, HKT<F, B>, HKT<F, C>, HKT<F, D>, HKT<F, E>>;
}
export declare const applyFirst: Ops['applyFirst'];
export declare const applySecond: Ops['applySecond'];
export declare const liftA2: Ops['liftA2'];
export declare const liftA3: Ops['liftA3'];
export declare const liftA4: Ops['liftA4'];
