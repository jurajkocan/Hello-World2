"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Ord_1 = require("./Ord");
var function_1 = require("./function");
var Either_1 = require("./Either");
exports.URI = 'Tuple';
var Tuple = /** @class */ (function () {
    function Tuple(value) {
        this.value = value;
    }
    Tuple.prototype.fst = function () {
        return this.value[0];
    };
    Tuple.prototype.snd = function () {
        return this.value[1];
    };
    Tuple.prototype.compose = function (ab) {
        return new Tuple([this.fst(), ab.snd()]);
    };
    Tuple.prototype.map = function (f) {
        return new Tuple([this.fst(), f(this.snd())]);
    };
    Tuple.prototype.bimap = function (f, g) {
        return new Tuple([f(this.fst()), g(this.snd())]);
    };
    Tuple.prototype.extract = function () {
        return this.snd();
    };
    Tuple.prototype.extend = function (f) {
        return new Tuple([this.fst(), f(this)]);
    };
    Tuple.prototype.reduce = function (f, c) {
        return f(c, this.snd());
    };
    Tuple.prototype.traverse = function (F) {
        var _this = this;
        return function (f) { return F.map(function (b) { return new Tuple([_this.fst(), b]); }, f(_this.snd())); };
    };
    Tuple.prototype.inspect = function () {
        return this.toString();
    };
    Tuple.prototype.toString = function () {
        return "new Tuple(" + function_1.toString(this.value) + ")";
    };
    return Tuple;
}());
exports.Tuple = Tuple;
/** Returns the first component of a tuple. */
exports.fst = function (fa) { return fa.fst(); };
/** Returns the second component of a tuple. */
exports.snd = function (fa) { return fa.snd(); };
exports.compose = function (bc) { return function (fa) {
    return fa.compose(bc);
}; };
exports.map = function (f, fa) { return fa.map(f); };
exports.bimap = function (f, g) { return function (fla) {
    return fla.bimap(f, g);
}; };
exports.extract = exports.snd;
exports.extend = function (f, fa) { return fa.extend(f); };
exports.reduce = function (f, c, fa) { return fa.reduce(f, c); };
exports.getSetoid = function (SA, SB) { return ({
    equals: function (x) { return function (y) {
        var _a = x.value, xa = _a[0], xb = _a[1];
        var _b = y.value, ya = _b[0], yb = _b[1];
        return SA.equals(xa)(ya) && SB.equals(xb)(yb);
    }; }
}); };
/**
 * To obtain the result, the `fst`s are `compare`d, and if they are `EQ`ual, the
 * `snd`s are `compare`d.
 */
exports.getOrd = function (OA, OB) {
    return Ord_1.getSemigroup().concat(Ord_1.contramap(exports.fst, OA))(Ord_1.contramap(exports.snd, OB));
};
exports.getSemigroup = function (SA, SB) { return ({
    concat: function (x) { return function (y) {
        var _a = x.value, xa = _a[0], xb = _a[1];
        var _b = y.value, ya = _b[0], yb = _b[1];
        return new Tuple([SA.concat(xa)(ya), SB.concat(xb)(yb)]);
    }; }
}); };
exports.getMonoid = function (MA, MB) {
    var empty = new Tuple([MA.empty(), MB.empty()]);
    return __assign({}, exports.getSemigroup(MA, MB), { empty: function () { return empty; } });
};
exports.getApply = function (S) { return ({
    URI: exports.URI,
    map: exports.map,
    ap: function (fab, fa) {
        return new Tuple([S.concat(fa.fst())(fab.fst()), fab.snd()(fa.snd())]);
    }
}); };
exports.getApplicative = function (monoidA) {
    var empty = monoidA.empty();
    return __assign({}, exports.getApply(monoidA), { of: function (a) {
            return new Tuple([empty, a]);
        } });
};
exports.getChain = function (M) { return (__assign({}, exports.getApply(M), { chain: function (f, fa) {
        var lb = f(fa.snd());
        return new Tuple([M.concat(fa.fst())(lb.fst()), lb.snd()]);
    } })); };
exports.getMonad = function (M) {
    var empty = M.empty();
    return __assign({}, exports.getChain(M), { of: function (b) {
            return new Tuple([empty, b]);
        } });
};
exports.chainRec = function (M) { return function (f, a) {
    var result = f(a);
    var acc = M.empty();
    while (Either_1.isLeft(result.snd())) {
        acc = M.concat(acc)(result.fst());
        result = f(result.snd().value);
    }
    return new Tuple([M.concat(acc)(result.fst()), result.snd().value]);
}; };
exports.getChainRec = function (M) { return (__assign({}, exports.getChain(M), { chainRec: exports.chainRec(M) })); };
var Ops = /** @class */ (function () {
    function Ops() {
    }
    Ops.prototype.traverse = function (F) {
        return function (f, ta) { return ta.traverse(F)(f); };
    };
    return Ops;
}());
exports.Ops = Ops;
var ops = new Ops();
exports.traverse = ops.traverse;
/** Exchange the first and second components of a tuple. */
exports.swap = function (fa) { return new Tuple([fa.snd(), fa.fst()]); };
exports.tuple = {
    URI: exports.URI,
    compose: exports.compose,
    map: exports.map,
    bimap: exports.bimap,
    extract: exports.extract,
    extend: exports.extend,
    reduce: exports.reduce,
    traverse: exports.traverse
};
//# sourceMappingURL=Tuple.js.map