"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Monoid_1 = require("./Monoid");
var function_1 = require("./function");
exports.URI = 'Option';
var None = /** @class */ (function () {
    function None() {
        this._tag = 'None';
    }
    None.prototype.map = function (f) {
        return exports.none;
    };
    /** Maps `f` over this Option's value. If the value returned from `f` is null or undefined, returns `None` */
    None.prototype.mapNullable = function (f) {
        return exports.none;
    };
    None.prototype.ap = function (fab) {
        return exports.none;
    };
    None.prototype.ap_ = function (fb) {
        return fb.ap(this);
    };
    None.prototype.chain = function (f) {
        return exports.none;
    };
    None.prototype.reduce = function (f, b) {
        return b;
    };
    None.prototype.traverse = function (F) {
        return function (f) { return F.of(exports.none); };
    };
    None.prototype.partitionMap = function (f) {
        return { left: exports.none, right: exports.none };
    };
    None.prototype.wilt = function (M) {
        return function (f) { return M.of({ left: exports.none, right: exports.none }); };
    };
    None.prototype.alt = function (fa) {
        return fa;
    };
    None.prototype.extend = function (f) {
        return exports.none;
    };
    None.prototype.fold = function (n, s) {
        return n();
    };
    None.prototype.getOrElse = function (f) {
        return f();
    };
    None.prototype.getOrElseValue = function (value) {
        return value;
    };
    None.prototype.concat = function (S) {
        return function (fy) { return fy; };
    };
    None.prototype.equals = function (S) {
        return function (fy) { return fy.fold(function_1.constTrue, function_1.constFalse); };
    };
    None.prototype.toNullable = function () {
        return null;
    };
    None.prototype.toUndefined = function () {
        return undefined;
    };
    None.prototype.inspect = function () {
        return this.toString();
    };
    None.prototype.toString = function () {
        return 'none';
    };
    /** Returns `true` if the option has an element that is equal (as determined by `S`) to `a`, `false` otherwise */
    None.prototype.contains = function (S, a) {
        return false;
    };
    /** Returns `true` if the option is `None`, false otherwise. */
    None.prototype.isNone = function () {
        return true;
    };
    /** Returns `true` if the option is an instance of `Some`, `false` otherwise */
    None.prototype.isSome = function () {
        return false;
    };
    /** Returns `true` if this option is non empty and the predicate `p` returns `true` when applied to this Option's value */
    None.prototype.exists = function (p) {
        return false;
    };
    /** Returns this option if it is non empty and the predicate `p` return `true` when applied to this Option's value. Otherwise returns `None` */
    None.prototype.filter = function (p) {
        return exports.none;
    };
    None.value = new None();
    return None;
}());
exports.None = None;
exports.none = None.value;
var Some = /** @class */ (function () {
    function Some(value) {
        this.value = value;
        this._tag = 'Some';
    }
    Some.prototype.map = function (f) {
        return new Some(f(this.value));
    };
    /** Maps `f` over this Option's value. If the value returned from `f` is null or undefined, returns `None` */
    Some.prototype.mapNullable = function (f) {
        return exports.fromNullable(f(this.value));
    };
    Some.prototype.ap = function (fab) {
        var _this = this;
        return fab.map(function (f) { return f(_this.value); });
    };
    Some.prototype.ap_ = function (fb) {
        return fb.ap(this);
    };
    Some.prototype.chain = function (f) {
        return f(this.value);
    };
    Some.prototype.reduce = function (f, b) {
        return this.fold(function_1.constant(b), function (a) { return f(b, a); });
    };
    Some.prototype.traverse = function (F) {
        var _this = this;
        return function (f) { return F.map(function (b) { return exports.some(b); }, f(_this.value)); };
    };
    Some.prototype.partitionMap = function (f) {
        return f(this.value).fold(function (l) { return ({ left: exports.some(l), right: exports.none }); }, function (a) { return ({ left: exports.none, right: exports.some(a) }); });
    };
    Some.prototype.wilt = function (M) {
        var _this = this;
        return function (f) {
            return M.map(function (e) {
                return e.fold(function (l) { return ({ left: exports.some(l), right: exports.none }); }, function (r) { return ({ left: exports.none, right: exports.some(r) }); });
            }, f(_this.value));
        };
    };
    Some.prototype.alt = function (fa) {
        return this;
    };
    Some.prototype.extend = function (f) {
        return new Some(f(this));
    };
    Some.prototype.fold = function (n, s) {
        return s(this.value);
    };
    Some.prototype.getOrElse = function (f) {
        return this.value;
    };
    Some.prototype.getOrElseValue = function (value) {
        return this.value;
    };
    Some.prototype.concat = function (S) {
        var _this = this;
        return function (fy) { return fy.fold(function () { return _this; }, function (y) { return new Some(S.concat(_this.value)(y)); }); };
    };
    Some.prototype.equals = function (S) {
        var _this = this;
        return function (fy) { return fy.fold(function_1.constFalse, function (y) { return S.equals(_this.value)(y); }); };
    };
    Some.prototype.toNullable = function () {
        return this.value;
    };
    Some.prototype.toUndefined = function () {
        return this.value;
    };
    Some.prototype.inspect = function () {
        return this.toString();
    };
    Some.prototype.toString = function () {
        return "some(" + function_1.toString(this.value) + ")";
    };
    /** Returns `true` if the option has an element that is equal (as determined by `S`) to `a`, `false` otherwise */
    Some.prototype.contains = function (S, a) {
        return S.equals(this.value)(a);
    };
    /** Returns `true` if the option is `None`, false otherwise */
    Some.prototype.isNone = function () {
        return false;
    };
    /** Returns `true` if the option is an instance of `Some`, `false` otherwise */
    Some.prototype.isSome = function () {
        return true;
    };
    /** Returns `true` if this option is non empty and the predicate `p` returns `true` when applied to this Option's value */
    Some.prototype.exists = function (p) {
        return p(this.value);
    };
    /** Returns this option if it is non empty and the predicate `p` return `true` when applied to this Option's value. Otherwise returns `None` */
    Some.prototype.filter = function (p) {
        return this.exists(p) ? this : exports.none;
    };
    return Some;
}());
exports.Some = Some;
exports.equals = function (S) { return function (fx) { return function (fy) { return fx.equals(S)(fy); }; }; };
exports.getSetoid = function (S) { return ({
    equals: exports.equals(S)
}); };
exports.map = function (f, fa) { return fa.map(f); };
/** Maps `f` over this Option's value. If the value returned from `f` is null or undefined, returns `None` */
exports.mapNullable = function (f, fa) { return fa.mapNullable(f); };
exports.of = function (a) { return new Some(a); };
exports.ap = function (fab, fa) { return fa.ap(fab); };
exports.chain = function (f, fa) { return fa.chain(f); };
exports.reduce = function (f, b, fa) { return fa.reduce(f, b); };
/** Returns this option if it is non empty and the predicate `p` return `true` when applied to this Option's value. Otherwise returns none */
exports.filter = function (p) { return function (fa) { return fa.filter(p); }; };
function alt(fx) {
    return function (fy) { return fx.alt(fy); };
}
exports.alt = alt;
exports.extend = function (f, ea) { return ea.extend(f); };
exports.zero = function () { return exports.none; };
exports.empty = exports.zero;
var first = { empty: exports.empty, concat: alt };
var last = Monoid_1.getDualMonoid(first);
/** Option monoid returning the left-most non-`None` value */
exports.getFirstMonoid = function () { return first; };
/** Option monoid returning the right-most non-`None` value */
exports.getLastMonoid = function () { return last; };
exports.concat = function (S) { return function (fx) { return function (fy) { return fx.concat(S)(fy); }; }; };
exports.getSemigroup = function (S) { return ({
    concat: exports.concat(S)
}); };
exports.getMonoid = function (S) { return (__assign({}, exports.getSemigroup(S), { empty: exports.empty })); };
exports.partitionMap = function (f, fa) { return fa.partitionMap(f); };
exports.wilt = function (M) { return function (f, ta) { return ta.wilt(M)(f); }; };
exports.isSome = function (fa) { return fa._tag === 'Some'; };
exports.isNone = function (fa) { return fa === exports.none; };
exports.fold = function (n, s, fa) { return fa.fold(n, s); };
/**
 * Takes a default value, and a `Option` value. If the `Option` value is
 * `None` the default value is returned, otherwise the value inside the
 * `Some` is returned
 */
exports.fromOption = function (a) { return function (fa) { return fa.getOrElseValue(a); }; };
exports.fromNullable = function (a) { return (a == null ? exports.none : new Some(a)); };
exports.toNullable = function (fa) { return fa.toNullable(); };
exports.toUndefined = function (fa) { return fa.toUndefined(); };
exports.some = exports.of;
exports.fromPredicate = function (predicate) { return function (a) { return (predicate(a) ? exports.some(a) : exports.none); }; };
var Ops = /** @class */ (function () {
    function Ops() {
    }
    Ops.prototype.traverse = function (F) {
        return function (f, ta) { return ta.traverse(F)(f); };
    };
    return Ops;
}());
exports.Ops = Ops;
var ops = new Ops();
exports.traverse = ops.traverse;
exports.option = {
    URI: exports.URI,
    map: exports.map,
    of: exports.of,
    ap: exports.ap,
    chain: exports.chain,
    reduce: exports.reduce,
    traverse: exports.traverse,
    zero: exports.zero,
    alt: alt,
    extend: exports.extend,
    partitionMap: exports.partitionMap,
    wilt: exports.wilt
};
//# sourceMappingURL=Option.js.map