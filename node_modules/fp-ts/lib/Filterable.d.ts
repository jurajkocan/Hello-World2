import { HKT, HKTS, HKT2S, HKTAs, HKT2As } from './HKT';
import { Functor, FantasyFunctor } from './Functor';
import { Either } from './Either';
import { Option } from './Option';
import { Predicate } from './function';
export interface Filterable<F> extends Functor<F> {
    /** partition a data structure based on an either predicate */
    partitionMap: <A, L, R>(f: (a: A) => Either<L, R>, fa: HKT<F, A>) => {
        left: HKT<F, L>;
        right: HKT<F, R>;
    };
}
export interface FantasyFilterable<F, A> extends FantasyFunctor<F, A> {
    /** partition a data structure based on an either predicate */
    partitionMap: <L, R>(f: (a: A) => Either<L, R>) => {
        left: HKT<F, L>;
        right: HKT<F, R>;
    };
}
export declare class Ops {
    /** partition a data structure based on boolean predicate */
    partition<F extends HKT2S>(F: Filterable<F>): <A>(predicate: Predicate<A>) => <L>(fa: HKT2As<F, L, A>) => {
        no: HKT2As<F, L, A>;
        yes: HKT2As<F, L, A>;
    };
    partition<F extends HKTS>(F: Filterable<F>): <A>(predicate: Predicate<A>) => (fa: HKTAs<F, A>) => {
        no: HKTAs<F, A>;
        yes: HKTAs<F, A>;
    };
    partition<F>(F: Filterable<F>): <A>(predicate: Predicate<A>) => (fa: HKT<F, A>) => {
        no: HKT<F, A>;
        yes: HKT<F, A>;
    };
    /** map over a data structure and filter based on a maybe */
    filterMap<F extends HKT2S>(F: Filterable<F>): <A, B>(f: (a: A) => Option<B>) => <L>(fa: HKT2As<F, L, A>) => HKT2As<F, L, B>;
    filterMap<F extends HKTS>(F: Filterable<F>): <A, B>(f: (a: A) => Option<B>) => (fa: HKTAs<F, A>) => HKTAs<F, B>;
    filterMap<F>(F: Filterable<F>): <A, B>(f: (a: A) => Option<B>) => (fa: HKT<F, A>) => HKT<F, B>;
    /** filter a data structure based on a boolean */
    filter<F extends HKT2S>(F: Filterable<F>): <A>(predicate: Predicate<A>) => <L>(fa: HKT2As<F, L, A>) => HKT2As<F, L, A>;
    filter<F extends HKTS>(F: Filterable<F>): <A>(predicate: Predicate<A>) => (fa: HKTAs<F, A>) => HKTAs<F, A>;
    filter<F>(F: Filterable<F>): <A>(predicate: Predicate<A>) => (fa: HKT<F, A>) => HKT<F, A>;
    partitioned<F extends HKT2S>(F: Filterable<F>): <L, M, R>(fa: HKT2As<F, M, Either<L, R>>) => {
        left: HKT2As<F, M, L>;
        right: HKT2As<F, M, R>;
    };
    partitioned<F extends HKTS>(F: Filterable<F>): <L, R>(fa: HKTAs<F, Either<L, R>>) => {
        left: HKTAs<F, L>;
        right: HKTAs<F, R>;
    };
    partitioned<F>(F: Filterable<F>): <L, R>(fa: HKT<F, Either<L, R>>) => {
        left: HKT<F, L>;
        right: HKT<F, R>;
    };
    /** Filter out all the `None` values */
    filtered<F extends HKT2S>(F: Filterable<F>): <L, A>(fa: HKT2As<F, L, Option<A>>) => HKT2As<F, L, A>;
    filtered<F extends HKTS>(F: Filterable<F>): <A>(fa: HKTAs<F, Option<A>>) => HKTAs<F, A>;
    filtered<F>(F: Filterable<F>): <A>(fa: HKT<F, Option<A>>) => HKT<F, A>;
}
export declare const partition: Ops['partition'];
export declare const filterMap: Ops['filterMap'];
export declare const filter: Ops['filter'];
export declare const partitioned: Ops['partitioned'];
export declare const filtered: Ops['filtered'];
