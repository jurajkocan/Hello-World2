import { HKT, HKTS, HKT2S, HKTAs, HKT2As } from './HKT';
import { Functor } from './Functor';
import { Applicative } from './Applicative';
import { Chain } from './Chain';
import { Monad } from './Monad';
import { Endomorphism } from './function';
export interface StateT<M> {
    map<S, A, B>(f: (a: A) => B, fa: (s: S) => HKT<M, [A, S]>): (s: S) => HKT<M, [B, S]>;
    of<S, A>(a: A): (s: S) => HKT<M, [A, S]>;
    ap<S, A, B>(fab: (s: S) => HKT<M, [(a: A) => B, S]>, fa: (s: S) => HKT<M, [A, S]>): (s: S) => HKT<M, [B, S]>;
    chain<S, A, B>(f: (a: A) => (s: S) => HKT<M, [B, S]>, fa: (s: S) => HKT<M, [A, S]>): (s: S) => HKT<M, [B, S]>;
}
export interface StateT1<M extends HKTS> {
    map<S, A, B>(f: (a: A) => B, fa: (s: S) => HKTAs<M, [A, S]>): (s: S) => HKTAs<M, [B, S]>;
    of<S, A>(a: A): (s: S) => HKTAs<M, [A, S]>;
    ap<S, A, B>(fab: (s: S) => HKTAs<M, [(a: A) => B, S]>, fa: (s: S) => HKTAs<M, [A, S]>): (s: S) => HKTAs<M, [B, S]>;
    chain<S, A, B>(f: (a: A) => (s: S) => HKTAs<M, [B, S]>, fa: (s: S) => HKTAs<M, [A, S]>): (s: S) => HKTAs<M, [B, S]>;
}
export interface StateT2<M extends HKT2S> {
    map<L, S, A, B>(f: (a: A) => B, fa: (s: S) => HKT2As<M, L, [A, S]>): (s: S) => HKT2As<M, L, [B, S]>;
    of<L, S, A>(a: A): (s: S) => HKT2As<M, L, [A, S]>;
    ap<L, S, A, B>(fab: (s: S) => HKT2As<M, L, [(a: A) => B, S]>, fa: (s: S) => HKT2As<M, L, [A, S]>): (s: S) => HKT2As<M, L, [B, S]>;
    chain<L, S, A, B>(f: (a: A) => (s: S) => HKT2As<M, L, [B, S]>, fa: (s: S) => HKT2As<M, L, [A, S]>): (s: S) => HKT2As<M, L, [B, S]>;
}
export declare class Ops {
    map<F extends HKT2S>(F: Functor<F>): <L, S, A, B>(f: (a: A) => B, fa: (s: S) => HKT2As<F, L, [A, S]>) => (s: S) => HKT2As<F, L, [B, S]>;
    map<F extends HKTS>(F: Functor<F>): <S, A, B>(f: (a: A) => B, fa: (s: S) => HKTAs<F, [A, S]>) => (s: S) => HKTAs<F, [B, S]>;
    map<F>(F: Functor<F>): <S, A, B>(f: (a: A) => B, fa: (s: S) => HKT<F, [A, S]>) => (s: S) => HKT<F, [B, S]>;
    of<F extends HKT2S>(F: Applicative<F>): <L, S, A>(a: A) => (s: S) => HKT2As<F, L, [A, S]>;
    of<F extends HKTS>(F: Applicative<F>): <S, A>(a: A) => (s: S) => HKTAs<F, [A, S]>;
    of<F>(F: Applicative<F>): <S, A>(a: A) => (s: S) => HKT<F, [A, S]>;
    ap<F extends HKT2S>(F: Chain<F>): <L, S, A, B>(fab: (s: S) => HKT2As<F, L, [(a: A) => B, S]>, fa: (s: S) => HKT2As<F, L, [A, S]>) => (s: S) => HKT2As<F, L, [B, S]>;
    ap<F extends HKTS>(F: Chain<F>): <S, A, B>(fab: (s: S) => HKTAs<F, [(a: A) => B, S]>, fa: (s: S) => HKTAs<F, [A, S]>) => (s: S) => HKTAs<F, [B, S]>;
    ap<F>(F: Chain<F>): <S, A, B>(fab: (s: S) => HKT<F, [(a: A) => B, S]>, fa: (s: S) => HKT<F, [A, S]>) => (s: S) => HKT<F, [B, S]>;
    chain<F extends HKT2S>(F: Chain<F>): <L, S, A, B>(f: (a: A) => (s: S) => HKT2As<F, L, [B, S]>, fa: (s: S) => HKT2As<F, L, [A, S]>) => (s: S) => HKT2As<F, L, [B, S]>;
    chain<F extends HKTS>(F: Chain<F>): <S, A, B>(f: (a: A) => (s: S) => HKTAs<F, [B, S]>, fa: (s: S) => HKTAs<F, [A, S]>) => (s: S) => HKTAs<F, [B, S]>;
    chain<F>(F: Chain<F>): <S, A, B>(f: (a: A) => (s: S) => HKT<F, [B, S]>, fa: (s: S) => HKT<F, [A, S]>) => (s: S) => HKT<F, [B, S]>;
    get<F extends HKT2S>(F: Applicative<F>): <S>() => <L>(s: S) => HKT2As<F, L, [S, S]>;
    get<F extends HKTS>(F: Applicative<F>): <S>() => (s: S) => HKTAs<F, [S, S]>;
    get<F>(F: Applicative<F>): <S>() => (s: S) => HKT<F, [S, S]>;
    put<F extends HKT2S>(F: Applicative<F>): <S>(s: S) => <L>() => HKT2As<F, L, [void, S]>;
    put<F extends HKTS>(F: Applicative<F>): <S>(s: S) => () => HKTAs<F, [void, S]>;
    put<F>(F: Applicative<F>): <S>(s: S) => () => HKT<F, [void, S]>;
    modify<F extends HKT2S>(F: Applicative<F>): <S>(f: Endomorphism<S>) => <L>(s: S) => HKT2As<F, L, [void, S]>;
    modify<F extends HKTS>(F: Applicative<F>): <S>(f: Endomorphism<S>) => (s: S) => HKTAs<F, [void, S]>;
    modify<F>(F: Applicative<F>): <S>(f: Endomorphism<S>) => (s: S) => HKT<F, [void, S]>;
    gets<F extends HKT2S>(F: Applicative<F>): <S, A>(f: (s: S) => A) => <L>(s: S) => HKT2As<F, L, [A, S]>;
    gets<F extends HKTS>(F: Applicative<F>): <S, A>(f: (s: S) => A) => (s: S) => HKTAs<F, [A, S]>;
    gets<F>(F: Applicative<F>): <S, A>(f: (s: S) => A) => (s: S) => HKT<F, [A, S]>;
    getStateT<M extends HKT2S>(M: Monad<M>): StateT2<M>;
    getStateT<M extends HKTS>(M: Monad<M>): StateT1<M>;
    getStateT<M>(M: Monad<M>): StateT<M>;
}
export declare const map: Ops['map'];
export declare const of: Ops['of'];
export declare const ap: Ops['ap'];
export declare const chain: Ops['chain'];
export declare const get: Ops['get'];
export declare const put: Ops['put'];
export declare const modify: Ops['modify'];
export declare const gets: Ops['gets'];
export declare const getStateT: Ops['getStateT'];
