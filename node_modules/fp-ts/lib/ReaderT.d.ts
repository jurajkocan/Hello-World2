import { HKT, HKTS, HKT2S, HKTAs, HKT2As } from './HKT';
import { Functor } from './Functor';
import { Applicative } from './Applicative';
import { Chain } from './Chain';
import { Monad } from './Monad';
export interface ReaderT<M> {
    map<E, A, B>(f: (a: A) => B, fa: (e: E) => HKT<M, A>): (e: E) => HKT<M, B>;
    of<E, A>(a: A): (e: E) => HKT<M, A>;
    ap<E, A, B>(fab: (e: E) => HKT<M, (a: A) => B>, fa: (e: E) => HKT<M, A>): (e: E) => HKT<M, B>;
    chain<E, A, B>(f: (a: A) => (e: E) => HKT<M, B>, fa: (e: E) => HKT<M, A>): (e: E) => HKT<M, B>;
}
export interface ReaderT1<M extends HKTS> {
    map<E, A, B>(f: (a: A) => B, fa: (e: E) => HKTAs<M, A>): (e: E) => HKTAs<M, B>;
    of<E, A>(a: A): (e: E) => HKTAs<M, A>;
    ap<E, A, B>(fab: (e: E) => HKTAs<M, (a: A) => B>, fa: (e: E) => HKTAs<M, A>): (e: E) => HKTAs<M, B>;
    chain<E, A, B>(f: (a: A) => (e: E) => HKTAs<M, B>, fa: (e: E) => HKTAs<M, A>): (e: E) => HKTAs<M, B>;
}
export interface ReaderT2<M extends HKT2S> {
    map<L, E, A, B>(f: (a: A) => B, fa: (e: E) => HKT2As<M, L, A>): (e: E) => HKT2As<M, L, B>;
    of<L, E, A>(a: A): (e: E) => HKT2As<M, L, A>;
    ap<L, E, A, B>(fab: (e: E) => HKT2As<M, L, (a: A) => B>, fa: (e: E) => HKT2As<M, L, A>): (e: E) => HKT2As<M, L, B>;
    chain<L, E, A, B>(f: (a: A) => (e: E) => HKT2As<M, L, B>, fa: (e: E) => HKT2As<M, L, A>): (e: E) => HKT2As<M, L, B>;
}
export declare class Ops {
    map<F extends HKT2S>(F: Functor<F>): <L, E, A, B>(f: (a: A) => B, fa: (e: E) => HKT2As<F, L, A>) => (e: E) => HKT2As<F, L, B>;
    map<F extends HKTS>(F: Functor<F>): <E, A, B>(f: (a: A) => B, fa: (e: E) => HKTAs<F, A>) => (e: E) => HKTAs<F, B>;
    map<F>(F: Functor<F>): <E, A, B>(f: (a: A) => B, fa: (e: E) => HKT<F, A>) => (e: E) => HKT<F, B>;
    of<F extends HKT2S>(F: Applicative<F>): <L, E, A>(a: A) => (e: E) => HKT2As<F, L, A>;
    of<F extends HKTS>(F: Applicative<F>): <E, A>(a: A) => (e: E) => HKTAs<F, A>;
    of<F>(F: Applicative<F>): <E, A>(a: A) => (e: E) => HKT<F, A>;
    ap<F extends HKT2S>(F: Applicative<F>): <L, E, A, B>(fab: (e: E) => HKT2As<F, L, (a: A) => B>, fa: (e: E) => HKT2As<F, L, A>) => (e: E) => HKT2As<F, L, B>;
    ap<F extends HKTS>(F: Applicative<F>): <E, A, B>(fab: (e: E) => HKTAs<F, (a: A) => B>, fa: (e: E) => HKTAs<F, A>) => (e: E) => HKTAs<F, B>;
    ap<F>(F: Applicative<F>): <E, A, B>(fab: (e: E) => HKT<F, (a: A) => B>, fa: (e: E) => HKT<F, A>) => (e: E) => HKT<F, B>;
    chain<F extends HKT2S>(F: Chain<F>): <L, E, A, B>(f: (a: A) => (e: E) => HKT2As<F, L, B>, fa: (e: E) => HKT2As<F, L, A>) => (e: E) => HKT2As<F, L, B>;
    chain<F extends HKTS>(F: Chain<F>): <E, A, B>(f: (a: A) => (e: E) => HKTAs<F, B>, fa: (e: E) => HKTAs<F, A>) => (e: E) => HKTAs<F, B>;
    chain<F>(F: Chain<F>): <E, A, B>(f: (a: A) => (e: E) => HKT<F, B>, fa: (e: E) => HKT<F, A>) => (e: E) => HKT<F, B>;
    ask<F extends HKT2S>(F: Applicative<F>): <L, E>() => (e: E) => HKT2As<F, L, E>;
    ask<F extends HKTS>(F: Applicative<F>): <E>() => (e: E) => HKTAs<F, E>;
    ask<F>(F: Applicative<F>): <E>() => (e: E) => HKT<F, E>;
    asks<F extends HKT2S>(F: Applicative<F>): <L, E, A>(f: (e: E) => A) => (e: E) => HKT2As<F, L, A>;
    asks<F extends HKTS>(F: Applicative<F>): <E, A>(f: (e: E) => A) => (e: E) => HKTAs<F, A>;
    asks<F>(F: Applicative<F>): <E, A>(f: (e: E) => A) => (e: E) => HKT<F, A>;
    getReaderT<M extends HKT2S>(M: Monad<M>): ReaderT2<M>;
    getReaderT<M extends HKTS>(M: Monad<M>): ReaderT1<M>;
    getReaderT<M>(M: Monad<M>): ReaderT<M>;
}
export declare const map: Ops['map'];
export declare const of: Ops['of'];
export declare const ap: Ops['ap'];
export declare const chain: Ops['chain'];
export declare const ask: Ops['ask'];
export declare const asks: Ops['asks'];
export declare const getReaderT: Ops['getReaderT'];
