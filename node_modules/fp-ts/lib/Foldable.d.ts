import { HKT, HKTS, HKT2S, HKTAs, HKT2As } from './HKT';
import { Monoid } from './Monoid';
import { Applicative } from './Applicative';
export interface Foldable<F> {
    readonly URI: F;
    reduce: <A, B>(f: (b: B, a: A) => B, b: B, fa: HKT<F, A>) => B;
}
export interface FantasyFoldable<A> {
    reduce: <B>(f: (b: B, a: A) => B, b: B) => B;
}
export interface FoldableComposition<F, G> {
    reduce: <A, B>(f: (b: B, a: A) => B, b: B, fga: HKT<F, HKT<G, A>>) => B;
}
export declare const getFoldableComposition: <F, G>(F: Foldable<F>, G: Foldable<G>) => FoldableComposition<F, G>;
/** A default implementation of `foldMap` using `foldl`. */
export declare const foldMap: <F, M>(F: Foldable<F>, M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: HKT<F, A>) => M;
export declare const fold: <F, M>(F: Foldable<F>, M: Monoid<M>) => (fa: HKT<F, M>) => M;
export declare const toArray: <F>(F: Foldable<F>) => <A>(fa: HKT<F, A>) => A[];
/** A default implementation of `foldr` using `foldMap` */
export declare const foldr: <F>(F: Foldable<F>) => <A, B>(f: (a: A) => (b: B) => B) => (b: B) => (fa: HKT<F, A>) => B;
/**
 * Fold a data structure, accumulating values in some `Monoid`,
 * combining adjacent elements using the specified separator
 */
export declare const intercalate: <F, M>(F: Foldable<F>, M: Monoid<M>) => (sep: M) => (fm: HKT<F, M>) => M;
export declare class Ops {
    /**
     * Traverse a data structure, performing some effects encoded by an
     * `Applicative` functor at each value, ignoring the final result.
     */
    traverse_<M extends HKT2S, F>(M: Applicative<M>, F: Foldable<F>): <L, A, B>(f: (a: A) => HKT2As<M, L, B>, fa: HKT<F, A>) => HKT2As<M, L, void>;
    traverse_<M extends HKTS, F>(M: Applicative<M>, F: Foldable<F>): <A, B>(f: (a: A) => HKTAs<M, B>, fa: HKT<F, A>) => HKTAs<M, void>;
    traverse_<M, F>(M: Applicative<M>, F: Foldable<F>): <A, B>(f: (a: A) => HKT<M, B>, fa: HKT<F, A>) => HKT<M, void>;
    /**
     * Perform all of the effects in some data structure in the order
     * given by the `Foldable` instance, ignoring the final result.
     */
    sequence_<M extends HKT2S, F>(M: Applicative<M>, F: Foldable<F>): <L, A>(fa: HKT<F, HKT2As<M, L, A>>) => HKT2As<M, L, void>;
    sequence_<M extends HKTS, F>(M: Applicative<M>, F: Foldable<F>): <A>(fa: HKT<F, HKTAs<M, A>>) => HKTAs<M, void>;
    sequence_<M, F>(M: Applicative<M>, F: Foldable<F>): <A>(fa: HKT<F, HKT<M, A>>) => HKT<M, void>;
}
export declare const traverse_: Ops['traverse_'];
export declare const sequence_: Ops['sequence_'];
