import { Either } from 'fp-ts/lib/Either';
import { Option } from 'fp-ts/lib/Option';
import { Predicate } from 'fp-ts/lib/function';
declare global  {
    interface Array<T> {
        _A: T;
    }
}
export interface ContextEntry {
    readonly key: string;
    readonly type: Any;
}
export declare type Context = Array<ContextEntry>;
export interface ValidationError {
    readonly value: any;
    readonly context: Context;
}
export declare type Validation<T> = Either<Array<ValidationError>, T>;
export declare type Validate<T> = (value: any, context: Context) => Validation<T>;
export declare type Any = Type<any>;
export declare type TypeOf<RT extends Any> = RT['_A'];
export interface Type<A> {
    readonly _A: A;
    readonly name: string;
    readonly validate: Validate<A>;
}
export declare const _A: never;
export declare const getFunctionName: (f: any) => string;
export declare const failure: <T>(value: any, context: ContextEntry[]) => Either<ValidationError[], T>;
export declare const success: <T>(value: T) => Either<ValidationError[], T>;
export declare const validate: <T>(value: any, type: Type<T>) => Either<ValidationError[], T>;
export declare const is: <T>(value: any, type: Type<T>) => value is T;
export declare class MapType<RT extends Any, A> implements Type<A> {
    readonly type: RT;
    readonly f: (a: TypeOf<RT>) => A;
    readonly name: string;
    readonly _tag: 'MapType';
    readonly _A: A;
    readonly validate: Validate<A>;
    constructor(type: RT, f: (a: TypeOf<RT>) => A, name: string);
}
export declare const map: <RT extends Type<any>, B>(f: (a: RT["_A"]) => B, type: RT) => MapType<RT, B>;
export declare const mapWithName: <RT extends Type<any>, B>(f: (a: RT["_A"]) => B, type: RT, name: string) => MapType<RT, B>;
export declare class NullType implements Type<null> {
    readonly _tag: 'NullType';
    readonly _A: null;
    readonly name: 'null';
    readonly validate: Validate<null>;
}
/** An alias of `null` */
export declare const nullType: NullType;
export declare class UndefinedType implements Type<undefined> {
    readonly _tag: 'UndefinedType';
    readonly _A: undefined;
    readonly name: 'undefined';
    readonly validate: Validate<undefined>;
}
declare const undefinedType: UndefinedType;
export declare class AnyType implements Type<any> {
    readonly _tag: 'AnyType';
    readonly _A: any;
    readonly name: 'any';
    readonly validate: Validate<any>;
}
export declare const any: AnyType;
export declare class NeverType implements Type<never> {
    readonly _tag: 'NeverType';
    readonly _A: never;
    readonly name: 'never';
    readonly validate: Validate<never>;
}
export declare const never: NeverType;
export declare class StringType implements Type<string> {
    readonly _tag: 'StringType';
    readonly _A: string;
    readonly name: 'string';
    readonly validate: Validate<string>;
}
export declare const string: StringType;
export declare class NumberType implements Type<number> {
    readonly _tag: 'NumberType';
    readonly _A: number;
    readonly name: 'number';
    readonly validate: Validate<number>;
}
export declare const number: NumberType;
export declare class BooleanType implements Type<boolean> {
    readonly _tag: 'BooleanType';
    readonly _A: boolean;
    readonly name: 'boolean';
    readonly validate: Validate<boolean>;
}
export declare const boolean: BooleanType;
export declare class AnyArrayType implements Type<Array<any>> {
    readonly _tag: 'AnyArrayType';
    readonly _A: Array<any>;
    readonly name: 'Array';
    readonly validate: Validate<Array<any>>;
}
declare const arrayType: AnyArrayType;
export declare class AnyDictionaryType implements Type<{
    [key: string]: any;
}> {
    readonly _tag: 'AnyDictionaryType';
    readonly _A: {
        [key: string]: any;
    };
    readonly name: 'Dictionary';
    readonly validate: Validate<{
        [key: string]: any;
    }>;
}
export declare const Dictionary: AnyDictionaryType;
export declare class FunctionType implements Type<Function> {
    readonly _tag: 'FunctionType';
    readonly _A: Function;
    readonly name: 'Function';
    readonly validate: Validate<Function>;
}
declare const functionType: FunctionType;
export declare class RefinementType<RT extends Any> implements Type<TypeOf<RT>> {
    readonly type: RT;
    readonly predicate: Predicate<TypeOf<RT>>;
    readonly name: string;
    readonly _tag: 'RefinementType';
    readonly _A: TypeOf<RT>;
    readonly validate: Validate<TypeOf<RT>>;
    constructor(type: RT, predicate: Predicate<TypeOf<RT>>, name?: string);
}
export declare const refinement: <RT extends Type<any>>(type: RT, predicate: Predicate<RT["_A"]>, name?: string | undefined) => RefinementType<RT>;
export declare const Integer: RefinementType<NumberType>;
export declare type GetOption<S, A> = (s: S) => Option<A>;
export declare class PrismType<RT extends Any, A> implements Type<A> {
    readonly type: RT;
    readonly getOption: GetOption<TypeOf<RT>, A>;
    readonly name: string;
    readonly _tag: 'PrismType';
    readonly _A: A;
    readonly validate: Validate<A>;
    constructor(type: RT, getOption: GetOption<TypeOf<RT>, A>, name?: string);
}
export declare const prism: <RT extends Type<any>, A>(type: RT, getOption: GetOption<RT["_A"], A>, name?: string | undefined) => PrismType<RT, A>;
export declare class LiteralType<V extends string | number | boolean> implements Type<V> {
    readonly value: V;
    readonly name: string;
    readonly _tag: 'LiteralType';
    readonly _A: V;
    readonly validate: Validate<V>;
    constructor(value: V, name?: string);
}
export declare const literal: <V extends string | number | boolean>(value: V, name?: string | undefined) => LiteralType<V>;
export declare class KeyofType<D extends {
    [key: string]: any;
}> implements Type<keyof D> {
    readonly keys: D;
    readonly name: string;
    readonly _tag: 'KeyofType';
    readonly _A: keyof D;
    readonly validate: Validate<keyof D>;
    constructor(keys: D, name?: string);
}
export declare const keyof: <D extends {
    [key: string]: any;
}>(keys: D, name?: string | undefined) => KeyofType<D>;
export declare class RecursiveType<T> implements Type<T> {
    readonly name: string;
    readonly validate: Validate<T>;
    readonly _tag: 'RecursiveType';
    readonly _A: T;
    readonly type: Any;
    constructor(name: string, validate: Validate<T>);
}
export declare const recursion: <T>(name: string, definition: (self: Type<any>) => Type<any>) => RecursiveType<T>;
export declare class ArrayType<RT extends Any> implements Type<Array<TypeOf<RT>>> {
    readonly type: RT;
    readonly name: string;
    readonly _tag: 'ArrayType';
    readonly _A: Array<TypeOf<RT>>;
    readonly validate: Validate<Array<TypeOf<RT>>>;
    constructor(type: RT, name?: string);
}
export declare const array: <RT extends Type<any>>(type: RT, name?: string | undefined) => ArrayType<RT>;
export declare type Props = {
    [key: string]: Any;
};
export declare type InterfaceOf<P extends Props> = {
    [K in keyof P]: TypeOf<P[K]>;
};
export declare class InterfaceType<P extends Props> implements Type<InterfaceOf<P>> {
    readonly props: P;
    readonly name: string;
    readonly _tag: 'InterfaceType';
    readonly _A: InterfaceOf<P>;
    readonly validate: Validate<InterfaceOf<P>>;
    constructor(props: P, name?: string);
}
/** An alias of `interface` */
export declare const type: <P extends Props>(props: P, name?: string | undefined) => InterfaceType<P>;
export declare type PartialOf<P extends Props> = {
    [K in keyof P]?: TypeOf<P[K]>;
};
export declare type PartialPropsOf<P extends Props> = {
    [K in keyof P]: UnionType<[P[K], Type<undefined>], [TypeOf<P[K]>, undefined]>;
};
export declare class PartialType<P extends Props> implements Type<PartialOf<P>> {
    readonly props: P;
    readonly _tag: 'PartialType';
    readonly _A: PartialOf<P>;
    readonly validate: Validate<PartialOf<P>>;
    readonly name: string;
    constructor(props: P, name?: string);
}
export declare const partial: <P extends Props>(props: P, name?: string | undefined) => PartialType<P>;
export declare class DictionaryType<D extends Type<string>, C extends Any> implements Type<{
    [K in TypeOf<D>]: TypeOf<C>;
}> {
    readonly domain: D;
    readonly codomain: C;
    readonly name: string;
    readonly _tag: 'DictionaryType';
    readonly _A: {
        [K in TypeOf<D>]: TypeOf<C>;
    };
    readonly validate: Validate<{
        [K in TypeOf<D>]: TypeOf<C>;
    }>;
    constructor(domain: D, codomain: C, name?: string);
}
export declare const dictionary: <D extends Type<string>, C extends Type<any>>(domain: D, codomain: C, name?: string | undefined) => DictionaryType<D, C>;
export declare class UnionType<RTS extends [Any], U = TypeOf<RTS['_A']>> implements Type<U> {
    readonly types: RTS;
    readonly name: string;
    readonly _tag: 'UnionType';
    readonly _A: U;
    readonly validate: Validate<U>;
    constructor(types: RTS, name?: string);
}
export declare const union: <RTS extends [Type<any>]>(types: RTS, name?: string | undefined) => UnionType<RTS, RTS["_A"]["_A"]>;
export declare class IntersectionType<RTS extends Array<Any>, I> implements Type<I> {
    readonly types: RTS;
    readonly name: string;
    readonly _tag: 'IntersectionType';
    readonly _A: I;
    readonly validate: Validate<I>;
    constructor(types: RTS, name?: string);
}
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any>(types: [A, B, C, D, E], name?: string): IntersectionType<[A, B, C, D, E], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D> & TypeOf<E>>;
export declare function intersection<A extends Any, B extends Any, C extends Any, D extends Any>(types: [A, B, C, D], name?: string): IntersectionType<[A, B, C, D], TypeOf<A> & TypeOf<B> & TypeOf<C> & TypeOf<D>>;
export declare function intersection<A extends Any, B extends Any, C extends Any>(types: [A, B, C], name?: string): IntersectionType<[A, B, C], TypeOf<A> & TypeOf<B> & TypeOf<C>>;
export declare function intersection<A extends Any, B extends Any>(types: [A, B], name?: string): IntersectionType<[A, B], TypeOf<A> & TypeOf<B>>;
export declare function intersection<A extends Any>(types: [A], name?: string): IntersectionType<[A], TypeOf<A>>;
export declare class TupleType<RTS extends Array<Any>, I> implements Type<I> {
    readonly types: RTS;
    readonly name: string;
    readonly _tag: 'TupleType';
    readonly _A: I;
    readonly validate: Validate<I>;
    constructor(types: RTS, name?: string);
}
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any, E extends Any>(types: [A, B, C, D, E], name?: string): TupleType<[A, B, C, D, E], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>, TypeOf<E>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any, D extends Any>(types: [A, B, C, D], name?: string): TupleType<[A, B, C, D], [TypeOf<A>, TypeOf<B>, TypeOf<C>, TypeOf<D>]>;
export declare function tuple<A extends Any, B extends Any, C extends Any>(types: [A, B, C], name?: string): TupleType<[A, B, C], [TypeOf<A>, TypeOf<B>, TypeOf<C>]>;
export declare function tuple<A extends Any, B extends Any>(types: [A, B], name?: string): TupleType<[A, B], [TypeOf<A>, TypeOf<B>]>;
export declare function tuple<A extends Any>(types: [A], name?: string): TupleType<[A], [TypeOf<A>]>;
export declare class ReadonlyType<RT extends Any> implements Type<Readonly<TypeOf<RT>>> {
    readonly type: RT;
    readonly name: string;
    readonly _tag: 'ReadonlyType';
    readonly _A: Readonly<TypeOf<RT>>;
    readonly validate: Validate<Readonly<TypeOf<RT>>>;
    constructor(type: RT, name?: string);
}
export declare const readonly: <RT extends Type<any>>(type: RT, name?: string | undefined) => ReadonlyType<RT>;
export declare class ReadonlyArrayType<RT extends Any> implements Type<ReadonlyArray<TypeOf<RT>>> {
    readonly type: RT;
    readonly name: string;
    readonly _tag: 'ReadonlyArrayType';
    readonly _A: ReadonlyArray<TypeOf<RT>>;
    readonly validate: Validate<ReadonlyArray<TypeOf<RT>>>;
    constructor(type: RT, name?: string);
}
export declare const readonlyArray: <RT extends Type<any>>(type: RT, name?: string | undefined) => ReadonlyArrayType<RT>;
export { nullType as null, undefinedType as undefined, arrayType as Array, functionType as Function, type as interface };
