"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Either_1 = require("fp-ts/lib/Either");
exports._A = undefined;
exports.getFunctionName = function (f) { return f.displayName || f.name || "<function" + f.length + ">"; };
var getContextEntry = function (key, type) { return ({ key: key, type: type }); };
var getValidationError = function (value, context) { return ({ value: value, context: context }); };
var pushAll = function (xs, ys) { return Array.prototype.push.apply(xs, ys); };
exports.failure = function (value, context) {
    return new Either_1.Left([getValidationError(value, context)]);
};
exports.success = function (value) { return new Either_1.Right(value); };
var getDefaultContext = function (type) { return [{ key: '', type: type }]; };
exports.validate = function (value, type) { return type.validate(value, getDefaultContext(type)); };
exports.is = function (value, type) { return Either_1.isRight(exports.validate(value, type)); };
var MapType = /** @class */ (function () {
    function MapType(type, f, name) {
        this.type = type;
        this.f = f;
        this.name = name;
        this._tag = 'MapType';
        this.validate = function (v, c) { return type.validate(v, c).map(f); };
    }
    return MapType;
}());
exports.MapType = MapType;
exports.map = function (f, type) {
    return exports.mapWithName(f, type, "(" + type.name + " => ?)");
};
exports.mapWithName = function (f, type, name) {
    return new MapType(type, f, name);
};
//
// basic types
//
var NullType = /** @class */ (function () {
    function NullType() {
        this._tag = 'NullType';
        this.name = 'null';
        this.validate = function (v, c) { return (v === null ? exports.success(v) : exports.failure(v, c)); };
    }
    return NullType;
}());
exports.NullType = NullType;
/** An alias of `null` */
exports.nullType = new NullType();
exports.null = exports.nullType;
var UndefinedType = /** @class */ (function () {
    function UndefinedType() {
        this._tag = 'UndefinedType';
        this.name = 'undefined';
        this.validate = function (v, c) { return (v === void 0 ? exports.success(v) : exports.failure(v, c)); };
    }
    return UndefinedType;
}());
exports.UndefinedType = UndefinedType;
var undefinedType = new UndefinedType();
exports.undefined = undefinedType;
var AnyType = /** @class */ (function () {
    function AnyType() {
        this._tag = 'AnyType';
        this.name = 'any';
        this.validate = function (v, _) { return exports.success(v); };
    }
    return AnyType;
}());
exports.AnyType = AnyType;
exports.any = new AnyType();
var NeverType = /** @class */ (function () {
    function NeverType() {
        this._tag = 'NeverType';
        this.name = 'never';
        this.validate = function (v, c) { return exports.failure(v, c); };
    }
    return NeverType;
}());
exports.NeverType = NeverType;
exports.never = new NeverType();
var StringType = /** @class */ (function () {
    function StringType() {
        this._tag = 'StringType';
        this.name = 'string';
        this.validate = function (v, c) { return (typeof v === 'string' ? exports.success(v) : exports.failure(v, c)); };
    }
    return StringType;
}());
exports.StringType = StringType;
exports.string = new StringType();
var NumberType = /** @class */ (function () {
    function NumberType() {
        this._tag = 'NumberType';
        this.name = 'number';
        this.validate = function (v, c) { return (typeof v === 'number' ? exports.success(v) : exports.failure(v, c)); };
    }
    return NumberType;
}());
exports.NumberType = NumberType;
exports.number = new NumberType();
var BooleanType = /** @class */ (function () {
    function BooleanType() {
        this._tag = 'BooleanType';
        this.name = 'boolean';
        this.validate = function (v, c) { return (typeof v === 'boolean' ? exports.success(v) : exports.failure(v, c)); };
    }
    return BooleanType;
}());
exports.BooleanType = BooleanType;
exports.boolean = new BooleanType();
var AnyArrayType = /** @class */ (function () {
    function AnyArrayType() {
        this._tag = 'AnyArrayType';
        this.name = 'Array';
        this.validate = function (v, c) { return (Array.isArray(v) ? exports.success(v) : exports.failure(v, c)); };
    }
    return AnyArrayType;
}());
exports.AnyArrayType = AnyArrayType;
var arrayType = new AnyArrayType();
exports.Array = arrayType;
var AnyDictionaryType = /** @class */ (function () {
    function AnyDictionaryType() {
        this._tag = 'AnyDictionaryType';
        this.name = 'Dictionary';
        this.validate = function (v, c) {
            return v !== null && typeof v === 'object' ? exports.success(v) : exports.failure(v, c);
        };
    }
    return AnyDictionaryType;
}());
exports.AnyDictionaryType = AnyDictionaryType;
exports.Dictionary = new AnyDictionaryType();
var FunctionType = /** @class */ (function () {
    function FunctionType() {
        this._tag = 'FunctionType';
        this.name = 'Function';
        this.validate = function (v, c) { return (typeof v === 'function' ? exports.success(v) : exports.failure(v, c)); };
    }
    return FunctionType;
}());
exports.FunctionType = FunctionType;
var functionType = new FunctionType();
exports.Function = functionType;
//
// refinements
//
var RefinementType = /** @class */ (function () {
    function RefinementType(type, predicate, name) {
        if (name === void 0) { name = "(" + type.name + " | " + exports.getFunctionName(predicate) + ")"; }
        this.type = type;
        this.predicate = predicate;
        this.name = name;
        this._tag = 'RefinementType';
        this.validate = function (v, c) { return type.validate(v, c).chain(function (t) { return (predicate(t) ? exports.success(t) : exports.failure(v, c)); }); };
    }
    return RefinementType;
}());
exports.RefinementType = RefinementType;
exports.refinement = function (type, predicate, name) { return new RefinementType(type, predicate, name); };
exports.Integer = exports.refinement(exports.number, function (n) { return n % 1 === 0; }, 'Integer');
var PrismType = /** @class */ (function () {
    function PrismType(type, getOption, name) {
        if (name === void 0) { name = "Prism<" + type.name + ", ?>"; }
        this.type = type;
        this.getOption = getOption;
        this.name = name;
        this._tag = 'PrismType';
        this.validate = function (v, c) { return type.validate(v, c).chain(function (a) { return getOption(a).fold(function () { return exports.failure(a, c); }, function (b) { return exports.success(b); }); }); };
    }
    return PrismType;
}());
exports.PrismType = PrismType;
exports.prism = function (type, getOption, name) { return new PrismType(type, getOption, name); };
//
// literal types
//
var LiteralType = /** @class */ (function () {
    function LiteralType(value, name) {
        if (name === void 0) { name = JSON.stringify(value); }
        this.value = value;
        this.name = name;
        this._tag = 'LiteralType';
        this.validate = function (v, c) { return (v === value ? exports.success(value) : exports.failure(v, c)); };
    }
    return LiteralType;
}());
exports.LiteralType = LiteralType;
exports.literal = function (value, name) {
    return new LiteralType(value, name);
};
//
// keyof types
//
var KeyofType = /** @class */ (function () {
    function KeyofType(keys, name) {
        if (name === void 0) { name = "(keyof " + JSON.stringify(Object.keys(keys)) + ")"; }
        this.keys = keys;
        this.name = name;
        this._tag = 'KeyofType';
        this.validate = function (v, c) { return (keys.hasOwnProperty(v) ? exports.success(v) : exports.failure(v, c)); };
    }
    return KeyofType;
}());
exports.KeyofType = KeyofType;
exports.keyof = function (keys, name) {
    return new KeyofType(keys, name);
};
//
// recursive types
//
var RecursiveType = /** @class */ (function () {
    function RecursiveType(name, validate) {
        this.name = name;
        this.validate = validate;
        this._tag = 'RecursiveType';
    }
    return RecursiveType;
}());
exports.RecursiveType = RecursiveType;
exports.recursion = function (name, definition) {
    var Self = new RecursiveType(name, function (v, c) { return type.validate(v, c); });
    var type = definition(Self);
    Self.type = type;
    return Self;
};
//
// arrays
//
var ArrayType = /** @class */ (function () {
    function ArrayType(type, name) {
        if (name === void 0) { name = "Array<" + type.name + ">"; }
        this.type = type;
        this.name = name;
        this._tag = 'ArrayType';
        this.validate = function (v, c) {
            return arrayType.validate(v, c).chain(function (as) {
                var t = [];
                var errors = [];
                var changed = false;
                var _loop_1 = function (i) {
                    var a = as[i];
                    var validation = type.validate(a, c.concat(getContextEntry(String(i), type)));
                    validation.fold(function (error) { return pushAll(errors, error); }, function (va) {
                        changed = changed || va !== a;
                        t.push(va);
                    });
                };
                for (var i = 0; i < as.length; i++) {
                    _loop_1(i);
                }
                return errors.length ? new Either_1.Left(errors) : exports.success(changed ? t : as);
            });
        };
    }
    return ArrayType;
}());
exports.ArrayType = ArrayType;
exports.array = function (type, name) { return new ArrayType(type, name); };
var InterfaceType = /** @class */ (function () {
    function InterfaceType(props, name) {
        if (name === void 0) { name = "{ " + Object.keys(props).map(function (k) { return k + ": " + props[k].name; }).join(', ') + " }"; }
        this.props = props;
        this.name = name;
        this._tag = 'InterfaceType';
        this.validate = function (v, c) {
            return exports.Dictionary.validate(v, c).chain(function (o) {
                var t = __assign({}, o);
                var errors = [];
                var changed = false;
                var _loop_2 = function (k) {
                    var ok = o[k];
                    var type_1 = props[k];
                    var validation = type_1.validate(ok, c.concat(getContextEntry(k, type_1)));
                    validation.fold(function (error) { return pushAll(errors, error); }, function (vok) {
                        changed = changed || vok !== ok;
                        t[k] = vok;
                    });
                };
                for (var k in props) {
                    _loop_2(k);
                }
                return errors.length ? new Either_1.Left(errors) : exports.success((changed ? t : o));
            });
        };
    }
    return InterfaceType;
}());
exports.InterfaceType = InterfaceType;
/** An alias of `interface` */
exports.type = function (props, name) { return new InterfaceType(props, name); };
exports.interface = exports.type;
var PartialType = /** @class */ (function () {
    function PartialType(props, name) {
        this.props = props;
        this._tag = 'PartialType';
        var partials = {};
        for (var k in props) {
            partials[k] = exports.union([props[k], undefinedType]);
        }
        var partial = exports.type(partials);
        this.name = name || partial.name;
        this.validate = function (v, c) { return partial.validate(v, c); };
    }
    return PartialType;
}());
exports.PartialType = PartialType;
exports.partial = function (props, name) { return new PartialType(props, name); };
//
// dictionaries
//
var DictionaryType = /** @class */ (function () {
    function DictionaryType(domain, codomain, name) {
        if (name === void 0) { name = "{ [key: " + domain.name + "]: " + codomain.name + " }"; }
        this.domain = domain;
        this.codomain = codomain;
        this.name = name;
        this._tag = 'DictionaryType';
        this.validate = function (v, c) {
            return exports.Dictionary.validate(v, c).chain(function (o) {
                var t = {};
                var errors = [];
                var changed = false;
                var _loop_3 = function (k) {
                    var ok = o[k];
                    var domainValidation = domain.validate(k, c.concat(getContextEntry(k, domain)));
                    var codomainValidation = codomain.validate(ok, c.concat(getContextEntry(k, codomain)));
                    domainValidation.fold(function (error) { return pushAll(errors, error); }, function (vk) {
                        changed = changed || vk !== k;
                        k = vk;
                    });
                    codomainValidation.fold(function (error) { return pushAll(errors, error); }, function (vok) {
                        changed = changed || vok !== ok;
                        t[k] = vok;
                    });
                };
                for (var k in o) {
                    _loop_3(k);
                }
                return errors.length ? new Either_1.Left(errors) : exports.success((changed ? t : o));
            });
        };
    }
    return DictionaryType;
}());
exports.DictionaryType = DictionaryType;
exports.dictionary = function (domain, codomain, name) { return new DictionaryType(domain, codomain, name); };
//
// unions
//
var UnionType = /** @class */ (function () {
    function UnionType(types, name) {
        if (name === void 0) { name = "(" + types.map(function (type) { return type.name; }).join(' | ') + ")"; }
        this.types = types;
        this.name = name;
        this._tag = 'UnionType';
        this.validate = function (v, c) {
            for (var i = 0; i < types.length; i++) {
                var validation = types[i].validate(v, c);
                if (Either_1.isRight(validation)) {
                    return validation;
                }
            }
            return exports.failure(v, c);
        };
    }
    return UnionType;
}());
exports.UnionType = UnionType;
exports.union = function (types, name) { return new UnionType(types, name); };
//
// intersections
//
var IntersectionType = /** @class */ (function () {
    function IntersectionType(types, name) {
        if (name === void 0) { name = "(" + types.map(function (type) { return type.name; }).join(' & ') + ")"; }
        this.types = types;
        this.name = name;
        this._tag = 'IntersectionType';
        this.validate = function (v, c) {
            var t = v;
            var changed = false;
            var errors = [];
            for (var i = 0; i < types.length; i++) {
                var type_2 = types[i];
                var validation = type_2.validate(t, c);
                validation.fold(function (error) { return pushAll(errors, error); }, function (vv) {
                    changed = changed || vv !== t;
                    t = vv;
                });
            }
            return errors.length ? new Either_1.Left(errors) : exports.success(changed ? t : v);
        };
    }
    return IntersectionType;
}());
exports.IntersectionType = IntersectionType;
function intersection(types, name) {
    return new IntersectionType(types, name);
}
exports.intersection = intersection;
//
// tuples
//
var TupleType = /** @class */ (function () {
    function TupleType(types, name) {
        if (name === void 0) { name = "[" + types.map(function (type) { return type.name; }).join(', ') + "]"; }
        this.types = types;
        this.name = name;
        this._tag = 'TupleType';
        this.validate = function (v, c) {
            return arrayType.validate(v, c).chain(function (as) {
                var t = [];
                var errors = [];
                var changed = false;
                var _loop_4 = function (i) {
                    var a = as[i];
                    var type_3 = types[i];
                    var validation = type_3.validate(a, c.concat(getContextEntry(String(i), type_3)));
                    validation.fold(function (error) { return pushAll(errors, error); }, function (va) {
                        changed = changed || va !== a;
                        t.push(va);
                    });
                };
                for (var i = 0; i < types.length; i++) {
                    _loop_4(i);
                }
                return errors.length ? new Either_1.Left(errors) : exports.success((changed ? t : as));
            });
        };
    }
    return TupleType;
}());
exports.TupleType = TupleType;
function tuple(types, name) {
    return new TupleType(types, name);
}
exports.tuple = tuple;
//
// readonly
//
var ReadonlyType = /** @class */ (function () {
    function ReadonlyType(type, name) {
        if (name === void 0) { name = "Readonly<" + type.name + ">"; }
        this.type = type;
        this.name = name;
        this._tag = 'ReadonlyType';
        this.validate = function (v, c) {
            return type.validate(v, c).map(function (x) {
                if (process.env.NODE_ENV !== 'production') {
                    return Object.freeze(x);
                }
                return x;
            });
        };
    }
    return ReadonlyType;
}());
exports.ReadonlyType = ReadonlyType;
exports.readonly = function (type, name) { return new ReadonlyType(type, name); };
//
// readonlyArray
//
var ReadonlyArrayType = /** @class */ (function () {
    function ReadonlyArrayType(type, name) {
        if (name === void 0) { name = "ReadonlyArray<" + type.name + ">"; }
        this.type = type;
        this.name = name;
        this._tag = 'ReadonlyArrayType';
        var arrayType = exports.array(type);
        this.validate = function (v, c) {
            return arrayType.validate(v, c).map(function (x) {
                if (process.env.NODE_ENV !== 'production') {
                    return Object.freeze(x);
                }
                return x;
            });
        };
    }
    return ReadonlyArrayType;
}());
exports.ReadonlyArrayType = ReadonlyArrayType;
exports.readonlyArray = function (type, name) {
    return new ReadonlyArrayType(type, name);
};
//# sourceMappingURL=index.js.map